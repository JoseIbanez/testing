<h1 id="vrealizebuildtoolsforvroprojects">vRealize Build Tools for vRO Projects</h1>
<p>Before you continue with this section validate that all of the prerequisites are met.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ul>
<li>Install and Configure <a href="./setup-workstation-maven.html">vRealize Build Tools System</a></li>
</ul>
<h1 id="use">Use</h1>
<h2 id="cratenewvroproject">Crate New vRO Project</h2>
<p>You start by bootstraping a new project using one of the provided archetypes:</p>
<h3 id="jsbasedactionsonlyproject">JS-Based Actions-Only Project</h3>
<p>This project contains only actions as *.js files. It does not handle an end-to-end functionality, but is an excellent choice as a
dependency for xml-based projects containing workflows, configurations and resource elements.</p>
<p>To create a new project of this type, you use the following command:</p>
<pre><code>mvn archetype:generate \
    -DinteractiveMode=false \
    -DarchetypeGroupId=com.vmware.pscoe.o11n.archetypes \
    -DarchetypeArtifactId=package-actions-archetype \
    -DarchetypeVersion=&lt;iac_for_vrealize_version&gt; \
    -DgroupId=local.corp.it.cloud \
    -DartifactId=dns
</code></pre>
<p>This will generate the following project file structure:</p>
<pre><code>dns
├── README.html
├── pom.xml
├── release.sh
└── src
    ├── main
    │&amp;nbsp;&amp;nbsp; └── resources
    │&amp;nbsp;&amp;nbsp;     ├── local
    │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp; └── corp
    │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     └── it
    │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;         └── cloud
    │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;             └── dns
    │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;                 └── sample.js
    │&amp;nbsp;&amp;nbsp;     ├── log4j.xml
    │&amp;nbsp;&amp;nbsp;     └── log4j2.xml
    └── test
        └── resources
            └── local
                └── corp
                    └── it
                        └── cloud
                            └── dns
                                └── SampleTests.js
</code></pre>
<p>You can delete the example action and test and start developing your code.</p>
<p>Every *.js file that follows the convention (see sample.js for reference) will be compiled into a vRO action where the
action name is the name of the file (e.g. sample) and the module (namespace) is the path
under <strong>src/main/resources</strong> (e.g. "local.corp.it.cloud.dns").</p>
<p>Actions in vRO are essentially functions that you can call by using <strong>System.getModule</strong>. In plain JavaScript, we model
 actions in the same way. Therefore, in the JS format it is required to have a single
 root function that represents the action. Since JavaScript is dynamically typed and vRO isn't, it is
 recommended to describe the parameter types and the return value type in JsDoc (see sample.js for reference).
 If you omit the JsDoc all types will be assumed to be be "Any".</p>
<h3 id="xmlbasedproject">Xml-Based Project</h3>
<p>This is the standard vRO project that can cover all use cases. It contains workflows, resource elements, configuration
elements, actions and policies and can have dependencies to any other vRO project type.</p>
<p>To create a new project of this type, you use the following command:</p>
<pre><code>mvn archetype:generate \
    -DinteractiveMode=false \
    -DarchetypeGroupId=com.vmware.pscoe.o11n.archetypes \
    -DarchetypeArtifactId=package-xml-archetype \
    -DarchetypeVersion=&lt;iac_for_vrealize_version&gt; \
    -DgroupId=local.corp.it.cloud \
    -DartifactId=dns \
    -DworkflowsPath=Corp/Cloud/Util
</code></pre>
<p>This will produce the following project file structure:</p>
<pre><code>util
├── pom.xml
├── release.sh
└── src
    └── main
        └── resources
            ├── Workflow
            │&amp;nbsp;&amp;nbsp; └── Corp
            │&amp;nbsp;&amp;nbsp;     └── Cloud
            │&amp;nbsp;&amp;nbsp;         └── Util
            │&amp;nbsp;&amp;nbsp;             ├── Install.element_info.xml
            │&amp;nbsp;&amp;nbsp;             └── Install.xml
            └── dunes-meta-inf.xml
</code></pre>
<p>You can delete the example elements.</p>
<p>You need to build and import the package in vRO and start developing your
code there. Make sure you sync the content from the vRO to your local file system regularly and commit your
  changes to SCM.</p>
<p>The <strong>Install</strong> workflow is the recommended way of automating the configuration/reconfiguration of your solution, so you can
use the workflow generated by the archetype as a starting point and develop your installation code from there.</p>
<h3 id="mixedproject">Mixed Project</h3>
<p>Mixed project acts as virtual project combining the both JS-Based Actions-Only and XML-based projects under single unified structure. Such project type is useful for initial onboarding of existing vRO code into the toolchain or when there is no need for XML-based and JS-Based Actions-Only projects to have separate lifecycle.</p>
<p>To create a new project of this type, you use the following command:</p>
<pre><code>mvn archetype:generate \
    -DinteractiveMode=false \
    -DarchetypeGroupId=com.vmware.pscoe.o11n.archetypes \
    -DarchetypeArtifactId=package-mixed-archetype \
    -DarchetypeVersion=&lt;iac_for_vrealize_version&gt; \
    -DgroupId=local.corp.it.cloud \
    -DartifactId=services \
    -DworkflowsPath=Corp/Cloud/Services
</code></pre>
<p>This will produce the following project file structure:</p>
<pre><code>services
├── actions
│&amp;nbsp;&amp;nbsp; ├── pom.xml
│&amp;nbsp;&amp;nbsp; └── src
│&amp;nbsp;&amp;nbsp;     ├── main
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp; └── resources
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     ├── local
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp; └── corp
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     └── it
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;         └── cloud
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;             └── services
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;                 └── sample.js
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     ├── log4j.xml
│&amp;nbsp;&amp;nbsp;     │&amp;nbsp;&amp;nbsp;     └── log4j2.xml
│&amp;nbsp;&amp;nbsp;     └── test
│&amp;nbsp;&amp;nbsp;         └── resources
│&amp;nbsp;&amp;nbsp;             └── local
│&amp;nbsp;&amp;nbsp;                 └── corp
│&amp;nbsp;&amp;nbsp;                     └── it
│&amp;nbsp;&amp;nbsp;                         └── cloud
│&amp;nbsp;&amp;nbsp;                             └── services
│&amp;nbsp;&amp;nbsp;                                 └── SampleTests.js
├── pom.xml
├── release.sh
└── workflows
    ├── pom.xml
    └── src
        └── main
            └── resources
                ├── Workflow
                │&amp;nbsp;&amp;nbsp; └── Corp
                │&amp;nbsp;&amp;nbsp;     └── Cloud
                │&amp;nbsp;&amp;nbsp;         └── Services
                │&amp;nbsp;&amp;nbsp;             ├── Install.element_info.xml
                │&amp;nbsp;&amp;nbsp;             └── Install.xml
                └── dunes-meta-inf.xml
</code></pre>
<h3 id="typescriptbasedproject">TypeScript-Based Project</h3>
<p><strong>EXPERIMENTAL</strong></p>
<p>This project contains actions as *.ts, workflows as *.wf.ts, configuration elements as *.config.ts and resource files.</p>
<p>To create a new project of this type, you use the following command:</p>
<pre><code>mvn archetype:generate \
    -DinteractiveMode=false \
    -DarchetypeGroupId=com.vmware.pscoe.o11n.archetypes \
    -DarchetypeArtifactId=package-typescript-archetype \
    -DarchetypeVersion=&lt;iac_for_vrealize_version&gt; \
    -DgroupId=local.corp.it.cloud \
    -DartifactId=demo
</code></pre>
<p>This will generate the following project file structure:</p>
<pre><code>demo
├── README.html
├── pom.xml
├── release.sh
└── src
    ├── sample.conf.ts
    ├── sample.test.ts
    ├── sample.ts
    └── sample.wf.ts
</code></pre>
<p>You can delete the examples and start developing your code.</p>
<p>Every *.ts file will be compiled into one of the corresponding types.</p>
<ul>
<li>Actions (sample.ts) will be compiled into the module < groupId >.< artifactId >.<the path under src/ folder></li>
<li>Tests (sample.test.ts) will not be added to the vRO package, but will be compiled into Javascript and triggered the same way as for the JS based projects</li>
<li>Configuration Elements (sample.conf.ts) and Workflows (sample.wf.ts) are going to be defined under the < artifactId >.<the path under src/ folder> category</li>
</ul>
<h4 id="examples">Examples</h4>
<h5 id="configurationelement">Configuration Element</h5>
<pre><code class="ts language-ts">export interface SampleConfig {
    field1: string;
    field2: number;
    field3: any;
}
</code></pre>
<h5 id="workflow">Workflow</h5>
<pre><code class="ts language-ts">import { Workflow, Out } from "tsc-annotations";

@Workflow({
    id: "c9be5b70-a650-43d0-a8a3-e39f731b055b",
    version: "1.0.0"
})
export class SampleWorkflow {
    public install(foo: string, bar: string, @Out result: any): void {
        System.log(`foo=${foo}, bar=${bar}`);
        result = "result value";
    }
}
</code></pre>
<h5 id="class">Class</h5>
<pre><code class="ts language-ts">export class SampleClass {
    public sum(x: number, y: number) {
        return x + y;
    }
}
</code></pre>
<h5 id="test">Test</h5>
<pre><code class="ts language-ts">import { SampleClass } from "./sample"

describe("Tests", () =&gt; {
    it("should sum two numbers", () =&gt; {
        expect(new SampleClass().sum(1, 2)).toBe(3)
    })
})
</code></pre>
<h5 id="action">Action</h5>
<pre><code class="ts language-ts">import { LoggerFactory } from "./LoggerFactory";
/**
 *
 * @param name
 * @param options
 */
(function getLogger(name:string, options?:any) {
    return new LoggerFactory().getLogger(name, options);
});
</code></pre>
<h2 id="unittesting">Unit Testing</h2>
<p>If you use <strong>js-based actions-only</strong> project, you can create unit tests to help you develop and verify your code.</p>
<p>The tests should be written using Jasmine, as one would do with any other JavaScript code. The only difference is that
there are a number of vRO scriptable objects (e.g. ConfigurationElement) that are not present in the enulated vRO scripting context.
You will have to mock those by overriding variables in the global scope.</p>
<p>For this project type, there is a Jasmine-JUnit adapter that is already configured. You place your tests under src/test
following the same folder structure as with the actions (e.g. <strong>src/test/local/corp/it/cloud/dns</strong>).</p>
<p>An example test file is shown bellow. It tests a custom action for working with configuration elements and for that it overrides
the Server and the ConfigurationElement scriptable object classes in the context:</p>
<pre><code class="js language-js">describe("Something", function() {
    ConfigurationElement = function (name, attributes) {
        this.attributes = attributes;
        this.configurationElementCategory = null;
        this.description = "";
        this.name = name;
        this.version = "0.0.0";
        this.getAttributeWithKey = function getAttributeWithKey (key) {
            return this.attributes[key];
        };
        this.removeAttributeWithKey = function removeAttributeWithKey (key) {
            delete this.attributes[key];
        };
        this.setAttributeWithKey = function setAttributeWithKey (key, value) {
            this.attributes[key] = {key: key, value: value};
        };

        this.reload = function() {
            // all up-to-date
        };
    };
    Server = {
        query: jasmine.createSpy('query').and.returnValue(new ConfigurationElement("test"))
    }

    it("should set attribute", function() {
        System.getModule("local.corp.it.cloud.dns").setAttribute("Corp/Cloud/Util/test", "value", 1);
        var value = System.getModule("local.corp.it.cloud.dns").getAttribute("Corp/Cloud/Util/test", "value");
        expect(value).toBe(1);
    });
    it("should ...", function() {
      ...
    });
});
</code></pre>
<p>Note that all tests in a single file are executed in a single context, i.e. any changes to the
global scope are persisted. However, different js files are executed in separate scripting contexts.</p>
<p>The Jasmine-JUnit adapter is part of the standard Maven lifecycle's testing phase, therefore tests will be
discovered and executed every time you build your project. However, you can trigger tests explicitly:</p>
<pre><code class="bash language-bash">mvn test # This will run all tests in the project without packaging it.
mvn test -Dtest=SomethingTest # This will run only tests in the SomethingTest.js file.
</code></pre>
<h2 id="building">Building</h2>
<p>You can build any vRO project from sources using Maven:</p>
<pre><code class="bash language-bash">mvn clean package
</code></pre>
<p>This will produce a vRO package with the groupId, artifactId and version specified in the pom. For example:</p>
<pre><code class="xml language-xml">&lt;groupId&gt;local.corp.it.cloud&lt;/groupId&gt;
&lt;artifactId&gt;dns&lt;/artifactId&gt;
&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;package&lt;/packaging&gt;
</code></pre>
<p>will result in <strong>local.corp.it.cloud.dns-1.0.0-SNAPSHOT.package</strong> generated in the target folder of your project.</p>
<p>In case you want to produce a bundle.zip containing the package and all its dependencies, you use:</p>
<pre><code class="bash language-bash">mvn clean pacakge -Pbundle
</code></pre>
<h2 id="pull">Pull</h2>
<p>When working on a vRO project, sometimes you might need to make changes on a live
server using the vRO Client, e.g. when working on workflows.</p>
<p>Although this is applicable for both
xml and js-based projects, it is more suitable for xml-based ones where you have the need to work
on workflows, configuration and resource elements.</p>
<p>To support this use case, the toolchain comes with a custom goal "vro:pull". The following command will "pull" the package
corresponding to the current project from a specified server and expand its content in the local filesystem overriding
any local content:</p>
<pre><code class="bash language-bash">vro:pull -Dvro.host=10.29.26.18 -Dvro.port=8281 -Dvro.username=administrator@vsphere.local -Dvro.password=***
</code></pre>
<p>Sometimes you want to pull the content of another package into your project. This can be achieved by providing the remote package name as parameter.</p>
<pre><code class="bash language-bash">vro:pull -DpackageName=com.vmware.pscoe.library.ssh -Dvro.host=10.29.26.18 -Dvro.port=8281 -Dvro.username=administrator@vsphere.local -Dvro.password=***
</code></pre>
<p>A better approach is to have the different vRO/vRA development environments specified as profiles in the local
settings.xml file by adding the following snippet under "profiles":</p>
<pre><code class="xml language-xml">&lt;servers&gt;
    &lt;server&gt;
        &lt;username&gt;administrator@vsphere.local&lt;/username&gt;
        &lt;password&gt;{native+maven+encrypted+pass}&lt;/password&gt;
        &lt;id&gt;corp-dev-vro&lt;/id&gt;
    &lt;/server&gt;
&lt;/servers&gt;
....
&lt;profile&gt;
    &lt;id&gt;corp-dev&lt;/id&gt;
    &lt;properties&gt;
        &lt;!--vRO Connection--&gt;
        &lt;vro.host&gt;10.29.26.18&lt;/vro.host&gt;
        &lt;vro.port&gt;8281&lt;/vro.port&gt;
        &lt;vro.serverId&gt;corp-dev-vro&lt;/vro.serverId&gt;
        &lt;vro.auth&gt;vra&lt;/vro.auth&gt;
        &lt;vro.tenant&gt;vsphere.local&lt;/vro.tenant&gt;
    &lt;/properties&gt;
&lt;/profile&gt;
</code></pre>
<p>Then, you can sync content back to your local sources by simply activating the profile:</p>
<pre><code class="bash language-bash">mvn vro:pull -Pcorp-env
</code></pre>
<h2 id="push">Push</h2>
<p>To deploy the code developed in the local project or checked out from source control to a live server, you can use
the <code>vrealize:push</code> command:</p>
<pre><code class="bash language-bash">mvn package vrealize:push -Pcorp-env
</code></pre>
<p>This will build the package and deploy it to the environment described in the <code>corp-env</code> profile. There are a few
additional options.</p>
<h2 id="includedependencies">Include Dependencies</h2>
<p>By default, the <code>vrealize:push</code> goal will deploy all dependencies of the current project to the target
environment. You can control that by the <code>-DincludeDependencies</code> flag. The value is <code>true</code> by default, so you
skip the dependencies by executing the following:</p>
<pre><code class="bash language-bash">mvn package vrealize:push -Pcorp-env -DincludeDependencies=false
</code></pre>
<p>Note that dependencies will not be deployed if the server has a newer version of the same package deployed. For example,
if the current project depends on <code>com.vmware.pscoe.example-2.4.0</code> and on the server there is <code>com.vmware.pscoe.example-2.4.2</code>,
the package will not be downgraded. You can force that by adding the <code>`-Dvro.importOldVersions</code> flag:</p>
<pre><code class="bash language-bash">mvn package vrealize:push -Pcorp-env -Dvro.importOldVersions
</code></pre>
<p>The command above will forcefully deploy the exact versions of the dependent packages, downgrading anything it finds on the server.</p>
<h3 id="ignorecertificateerrorsnotrecommended">Ignore Certificate Errors (Not recommended)</h3>
<blockquote>
  <p>This section describes how to bypass a security feature in development/testing environment. <strong>Do not use those flags when targeting production servers.</strong> Instead, make sure the certificates have the correct CN, use FQDN to access the servers and add the certificates to Java's key store (i.e. cacerts).</p>
</blockquote>
<p>You can ignore certificate errors, i.e. the certificate is not trusted, by adding the flag <code>-Dvrealize.ssl.ignore.certificate</code>:</p>
<pre><code class="bash language-bash">mvn package vrealize:push -Pcorp-env -Dvrealize.ssl.ignore.certificate
</code></pre>
<p>You can ignore certificate hostname error, i.e. the CN does not match the actual hostname, by adding the flag <code>-Dvrealize.ssl.ignore.certificate</code>:</p>
<pre><code class="bash language-bash">mvn package vrealize:push -Pcorp-env -Dvrealize.ssl.ignore.hostname
</code></pre>
<p>You can also combine the two options above.</p>
<p>The other option is to set the flags in your Maven's settings.xml file for a specific <strong>development</strong> environment.</p>
<pre><code class="xml language-xml">&lt;profile&gt;
    &lt;id&gt;corp-dev&lt;/id&gt;
    &lt;properties&gt;
        &lt;!--vRO Connection--&gt;
        &lt;vro.host&gt;10.29.26.18&lt;/vro.host&gt;
        &lt;vro.port&gt;8281&lt;/vro.port&gt;
        &lt;vro.username&gt;administrator@vsphere.local&lt;/vro.username&gt;
        &lt;vro.password&gt;***&lt;/vro.password&gt;
        &lt;vro.auth&gt;vra&lt;/vro.auth&gt;
        &lt;vro.tenant&gt;vsphere.local&lt;/vro.tenant&gt;
        &lt;vrealize.ssl.ignore.hostname&gt;true&lt;/vrealize.ssl.ignore.hostname&gt;
        &lt;vrealize.ssl.ignore.certificate&gt;true&lt;/vrealize.ssl.ignore.certificate&gt;
    &lt;/properties&gt;
&lt;/profile&gt;
</code></pre>
<h2 id="bundling">Bundling</h2>
<p>To produce a bundle.zip containing the package and all its dependencies, use:</p>
<pre><code>$ mvn clean deploy -Pbundle
</code></pre>
<p>Refer to <a href="./setup-workstation-maven.html">vRealize Build Tools</a>/Bundling for more information.</p>
<h2 id="cleanup">Clean Up</h2>
<p>To clean up a version of vRO package from the server use:</p>
<ul>
<li>Clean up only curent package version from the server
<code>
mvn vrealize:clean -DcleanUpLastVersion=true -DcleanUpOldVersions=false -DincludeDependencies=false
</code></li>
<li>Clean up curent package version from the server and its dependencies. This is a force removal operation.
<code>
mvn vrealize:clean -DcleanUpLastVersion=true -DcleanUpOldVersions=false -DincludeDependencies=true
</code></li>
<li>Clean up old package versions and the old vertions of package dependencies.
<code>
mvn vrealize:clean -DcleanUpLastVersion=false -DcleanUpOldVersions=true -DincludeDependencies=true
</code></li>
</ul>
<h2 id="troubleshooting">Troubleshooting</h2>
<ul>
<li>If Maven error does not contain enough information rerun it with <em>-X</em> debug flag.</li>
</ul>
<pre><code class="Bash language-Bash">mvn -X &lt;rest of the command&gt;
</code></pre>
<ul>
<li>Sometimes Maven might cache old artifats. Force fetching new artifacts with <em>-U</em>. Alternativelly remove <em><home>/.m2/repository</em> folder.</li>
</ul>
<pre><code class="Bash language-Bash">mvn -U &lt;rest of the command&gt;
</code></pre>